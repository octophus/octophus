'use babel';

import fs from 'fs-plus';
import tmp from 'tmp';
import Promise from 'bluebird';
import mkdirp from 'mkdirp';
import pathutil from 'path';
import github from './auth';
import Directory from './directory';

export default class Repository {
  constructor(owner, repo, branch) {
    this.owner = owner;
    this.name = repo;

    let branch_promise;
    if (branch) {
      branch_promise = new Promise((resolve) => {
        resolve(branch);
      });
    } else {
      branch_promise = github.repos.get({ owner: owner, repo: repo }).then(obj => {
        return obj.default_branch;
      });
    }
    this.sha_promise = branch_promise.then(branch_name => {
      this.branch = branch_name;
    }).then(() => {
      return github.gitdata.getReference({
        owner: owner,
        repo: repo,
        ref: "heads/" + this.branch
      });
    }).then(tree_root => {
      this.sha = tree_root.object.sha;
    }).catch(err => {
      throw err;
    });

    this.tmppath_promise = new Promise((resolve, reject) => {
      tmp.dir({ mode: 0o700, prefix: 'octophus_' }, (err, path, cleanup_callback) => {
        if (err) reject(err);
        this.tmppath = path;
        this.cleanup_callback = cleanup_callback;
        resolve(path);
      });
    });
  }

  destroy() {
    if (this.cleanup_callback) this.cleanup_callback();
  }

  getDirectory() {
    return Promise.all([
      this.sha_promise,
      this.tmppath_promise
    ]).then(() => {
      if (typeof this._root == "undefined") {
        this._root = new Directory(this, "/", this.tmppath, undefined, this.sha);
      }
      return this._root;
    }).catch(err => {
      throw err;
    })
  }

  updateHeadRefs(sha, force = true) {
    return github.gitdata.updateReference({
      owner: this.owner,
      repo: this.name,
      ref: 'heads/' + this.branch,
      sha: sha,
      force: force
    });
  }

  commit(message, tree_sha, parents) {
    return github.gitdata.createCommit({
      owner: this.owner,
      repo: this.name,
      message: message,
      tree: tree_sha,
      parents: parents
    });
  }

  // Change the commit message of last commit and prevent further commit clashing this commit.
  amendCommitMessage(message) {
    return github.gitdata.getReference({
      owner: this.owner,
      repo: this.name,
      ref: "heads/" + this.branch,
    }).then(obj => github.gitdata.getCommit({
      owner: this.owner,
      repo: this.name,
      sha: obj.object.sha,
    })).then(obj => github.gitdata.createCommit({
      owner: this.owner,
      repo: this.name,
      message: message,
      tree: obj.tree.sha,
      parents: obj.parents.map(x => x.sha),
    })).then(obj => this.updateHeadRefs(obj.sha, true))
      .then(obj => this.sha = obj.object.sha);
  }

  saveAll() {
    if (!this._save_all_promise) {
      this._save_all_promise = new Promise((resolve, reject) => {
        resolve();
      });
    }
    this._save_all_promise = this._save_all_promise.then(() => {
      return this.getDirectory().then(root => {
        return root.saveRemote();
      }).then(sha => {
        if (sha.length != 1) throw 'no change';
        return this.commit('Auto generated by Octophus', sha[0], [this.sha]);
      }).then(obj => {
        return this.updateHeadRefs(obj.sha, true);
      });
    }).catch(e => {
      console.log(e);
    });
    return this._save_all_promise;
  }
}
